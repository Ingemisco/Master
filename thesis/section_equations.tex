\section{Equation Solving}
\label{sec:equation_solving}
Before delving into the core simplification algorithms, we must address a fundamental subproblem: the \emph{line segment intersection problem}.

\begin{definition}[Line Segment Intersection Problem]
  Let \(e = \overline{e_1e_2}\) be a \(d\)-dimensional line segment, \(u \in \R^d\) a point, \(\varepsilon > 0\), and \(\delta\) a distance function. The \emph{line segment intersection problem} is to determine the set
	\[\set{t \in [0, 1] \mid \delta(e_1 + t(e_2 - e_1), u) \leq \varepsilon},\]
	where \(t\) is the parameter along the line segment \(e\).

  Geometrically, this corresponds to the intersection of the line segment \(e\) and the set of points within distance \(\varepsilon\) of \(u\), \(\set{x \in \R^d \mid \delta(x, u) \leq \varepsilon}\).
\end{definition}

\begin{observation}
	For any \(\ell \in [1, \infty]\), the solution set to the line segment intersection problem using the distance \(\delta_\ell\) is convex. Therefore, it can be expressed as a single (possibly empty) closed interval \(I \subseteq [0, 1]\), identifiable by its left and right boundaries.
\end{observation}

\begin{proof}
  This follows directly from the convexity property in \cref{lem:distance_properties} and the fact that both the line segment and the \(\varepsilon\)-ball are convex sets.
\end{proof}

This convexity simplifies the problem to finding the interval's boundaries. We do this by solving the equation
\begin{equation}
  \delta(u + t \cdot (v - u), w) = \varepsilon \label{eq:eq_solve_main}
\end{equation}
for \(t \in \R\), given fixed vectors \(u, v, w \in \R^d\) and \(\varepsilon > 0\). This equation finds points on the entire line through \(u\) and \(v\) that are at distance \(\varepsilon\) from \(w\).

Let \(\hat{t}_0\) and \(\hat{t}_1\) be the smallest and largest solutions to \cref{eq:eq_solve_main}, respectively. These may lie outside the interval \([0,1]\), coincide (a single point solution), or may not exist. The actual solution interval for the line segment \(\overline{uv}\) is \([\hat t_0, \hat t_1] \cap [0, 1]\). We define the modified solutions \(\hat{t}_0'\) and \(\hat{t}_1'\) that account for the segment boundaries:

\begin{equation}
  \hat{t}_0' \coloneq \begin{cases}
    0 & \text{if } \hat{t}_0 < 0 \text{ and } \hat{t}_1 \geq 0,\\
    \hat{t}_0 & \text{if } \hat{t}_0 \in [0, 1],\\
    \infty &\text{otherwise},
  \end{cases}
	\quad
  \hat{t}_1' \coloneq \begin{cases}
    1 & \text{if } \hat{t}_1 > 1 \text{ and } \hat{t}_0 \leq 1,\\
    \hat{t}_1 & \text{if } \hat{t}_1 \in [0, 1],\\
    \infty &\text{otherwise}.
  \end{cases}
\end{equation}

The \(\infty\) value indicates an empty intersection. \Cref{fig:solution_kinds} illustrates these cases. For a line segment \(\overline{uv}\) and point \(w\), we denote the relevant solutions as \(\hat t_0'(\overline{uv}, w)\) and \(\hat t_1'(\overline{uv}, w)\); the parameter \(\varepsilon\) is omitted as it is fixed contextually.

\begin{figure}
    \centering
    % First row of subfigures
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-1.pdf}
      \caption{\(\hat t_0 < 0 < \hat t_1 < 1\) \\
        \(\hat t_0' = 0, \hat t_1' = \hat t_1\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-2.pdf}
      \caption{\(0 < \hat t_0 < \hat t_1 < 1\) \\
        \(\hat t_0' = \hat t_0, \hat t_1' = \hat t_1\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-3.pdf}
      \caption{\(0 < \hat t_0 < 1 < \hat t_1 \) \\
        \(\hat t_0' = \hat t_0, \hat t_1' = 1\)}
    \end{subfigure}

    % Second row of subfigures
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-4.pdf}
      \caption{\(\hat t_0 < \hat t_1 < 0\) \\
        \(\hat t_0' = \hat t_1' = \infty\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-5.pdf}
      \caption{\(\hat t_0 < 0 < 1 < \hat t_1\) \\
        \(\hat t_0' = 0, \hat t_1' = 1\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-6.pdf}
      \caption{\(1 < \hat t_0 < \hat t_1\) \\
        \(\hat t_0' =  \hat t_1' = \infty\)}
    \end{subfigure}

    % Third row of subfigures (centered)
    \begin{subfigure}[t]{0.3\textwidth}
      \includegraphics{tikz-fig/solution-kinds-7.pdf}
      \caption{\(\hat t_0, \hat t_1\) do not exist \\
        \(\hat t_0' = \hat t_1' = \infty\)}
    \end{subfigure}
    \caption{The different kinds of solutions. Note that we associate \(0\) with \(u\), \(1\) with \(v\), and \(t\) with \((1-t)u + tv\)}
    \label{fig:solution_kinds}
\end{figure}

Solving \cref{eq:eq_solve_main} generally involves finding roots of polynomials. For Minkowski distances \(\delta_\ell\) with \(\ell > 4\), no closed-form solution exists due to the Abel-Ruffini theorem. We now derive explicit solutions for the Euclidean, Manhattan, and Chebyshev distances.

\subsection{Euclidean Distance}
\label{ssec:eq_euclidean_distance}
For the Euclidean distance \(\delta_2\), \cref{eq:eq_solve_main} becomes:
\begin{align*}
  \| (u - w) + t(v - u) \|_2 &= \varepsilon \\
  \| (u - w) + t(v - u) \|_2^2 &= \varepsilon^2.
\end{align*}
Expanding the squared norm yields a quadratic equation in \(t\):
\begin{align*}
  \| u - w \|_2^2 + 2\braket{u - w | v - u} t + \| v - u \|_2^2 t^2 &= \varepsilon^2.
\end{align*}
Define the coefficients:
\begin{align*}
	\alpha_0 &= \delta(u,w)^2 - \varepsilon^2, \\
	\alpha_1 &= \braket{u - w | v - u}, \\
	\alpha_2 &= \delta(v, u)^2.
\end{align*}
The equation is \(\alpha_0 + 2\alpha_1 t + \alpha_2 t^2 = 0\). The solutions are:
\begin{equation}
	\hat t_{0,1} = \frac{-\alpha_1 \pm \sqrt{\alpha_1^2 - \alpha_0\alpha_2}}{\alpha_2}.\label{eq:sol_explicit_euclidean}
\end{equation}
If the discriminant \(\alpha_1^2 - \alpha_0\alpha_2\) is negative, there are no real solutions. Otherwise, \(\hat{t}_0\) and \(\hat{t}_1\) are the smaller and larger root, respectively. Here, we use Dirac notation for the inner product as \(\langle \cdot , \cdot \rangle\) denotes a polyline of length \(1\).

\subsection{Manhattan Distance}
\label{ssec:eq_manhattan_distance}
For the Manhattan distance \(\delta_1\), the equation is:
\begin{equation}
  \sum_{i=1}^d |u_i - w_i + t (v_i - u_i)| = \varepsilon. \label{eq:solve_manhattan}
\end{equation}

We use the following invariance property:
\begin{observation}\label{obs:permute-coordinates}
	Let \(\sigma\) be a permutation of \(\set{1, \dots, d}\). For any \(\ell \in [1, \infty]\), \(\delta_\ell(u, v) = \delta_\ell(\sigma(u), \sigma(v))\), where \(\sigma(u)\) denotes permuting the coordinates of \(u\).
\end{observation}

Each term \(|u_i - w_i + t (v_i - u_i)|\) is a piecewise linear function in \(t\), with a breakpoint at \(t_i = (w_i - u_i)/(v_i - u_i)\), where the expression inside the absolute value is zero. For a fixed \(t\), the sum becomes linear.

Let \(\sigma\) be a permutation that sorts the breakpoints: \(t_{\sigma(1)} \leq t_{\sigma(2)} \leq \dots \leq t_{\sigma(d)}\). By \cref{obs:permute-coordinates}, we can analyze the problem in this sorted order. In each interval between consecutive breakpoints, the equation is linear and can be solved for \(t\). We check if the solution lies within the current interval.

A na\"ive sweep-line algorithm would sort the breakpoints (\(\O(d \log d)\)) and check each of the \(d+1\) intervals in \(\O(d)\) time, leading to \(\O(d^2)\) total time. However, because only one term changes sign between intervals, the linear expression can be updated in constant time, reducing the total time to \(\O(d \log d)\).

We handle edge cases as follows:
\begin{itemize}
	\item Coinciding breakpoints require no special treatment; the function remains contiunous.
	\item If \(v_i = u_i\), the term is constant \(|u_i - w_i|\) and is subtracted from \(\varepsilon\).
\end{itemize}

\begin{algorithm}[ht]
  \DontPrintSemicolon
  \KwData{Vectors \(u, v, w \in \R^d\), \(\varepsilon > 0\)}
  \KwResult{Solution to \cref{eq:solve_manhattan}}
  \BlankLine
  \(global\_slope \gets 0, global\_offset \gets 0\) \;
  \(events \gets Array(d)\) \;
  \For{\(i = 1\) \KwTo \(d\)}{
    \(slope \gets v_i - u_i, offset \gets u_i - w_i\)\;
    \If{\(slope < 0\)}{
      \(slope \gets -slope, offset \gets -offset\)
    } \ElseIf{\(slope = 0\)}{
      \(\varepsilon \gets \varepsilon - |offset|\)\;
      \Continue
    }
    \(zero \gets - \frac{offset}{slope}\)\;
    \If{\(zero \leq 0\)}{
      \(global\_offset \gets global\_offset + offset\)\;
      \(global\_slope \gets global\_slope + slope\)\;
      \Continue
    }
    \(global\_offset \gets global\_offset - offset\)\;
    \(global\_slope \gets global\_slope - slope\)\;
    \If{\(zero \geq 1\)}{
      \Continue
    }
    \(events.append((zero, slope, offset))\)\;
  }
  Sort \(events\) by their \(zero\) component\;
  \(start \gets 0\)\;
  \For{\((zero, slope, offset) \in events\)}{
    Test if solution \(\frac{\varepsilon - global\_offset}{global\_slope} \in [start, zero]\) and report it if so\;
    \(global\_offset \gets global\_offset + 2offset\)\;
    \(global\_slope \gets global\_slope + 2slope\)\;
    \(start \gets zero\)
  }
  Test if solution \(\frac{\varepsilon - global\_offset}{global\_slope} \in [start, 1]\) and report it if so\;

  \caption{manhattan\_solver(\(u, v, w, \varepsilon\))}
  \label{algo:solve_manhattan}
\end{algorithm}

\paragraph{Linear-Time Variant using Quickselect}
The runtime can be reduced to expected \(\O(d)\) time by noting that a full sort is unnecessary; we only need the breakpoints that bound the potential solutions. This can be achieved with a modified Quickselect algorithm.

We represent each coordinate's contribution as a pair \((a, b)\) corresponding to \(|a + b t|\). The zero of this term is at \(t = -a/b\). We define an ordering between pairs \((a, b)\) and \((c, d)\) based on their zeros: \((a, b) < (c, d) \iff a d > b c\). This comparison is division-free and numerically stable.

The algorithm proceeds as follows:
\begin{enumerate}
	\item Start with artificial left and right boundaries representing \(t = -\infty\) and \(t = \infty\).
	\item Select a pivot pair and partition the other pairs based on their zero relative to the pivot's zero.
	\item Merge all pairs with the same zero into the pivot.
	\item Evaluate the Manhattan distance at the pivot's zero using the current global linear function (maintained incrementally).
	\item Exploiting the convexity of the distance function, determine whether a solution exists to the left, right, or on both sides of the pivot, and recurse on the relevant partition.
\end{enumerate}

This method finds the solutions in expected \(\O(d)\) time. A deterministic \(\O(d)\) worst-case time is possible using median-of-medians for pivot selection.

\subsection{Chebyshev Distance}
\label{ssec:eq_chebyshev_distance}
For the Chebyshev distance \(\delta_\infty\), the equation is:
\begin{equation}
  \max_{i = 1,\dots, d} |u_i - w_i + t(v_i - u_i)| = \varepsilon.\label{eq:solve_chebyshev}
\end{equation}

\paragraph{Na\"ive Approach}
A simple method considers all \(2d\) candidate expressions (positive and negative branches of each absolute value). For each candidate \(t\) where a specific term might achieve the maximum, we check if it indeed equals \(\varepsilon\) and is maximal. This leads to an \(\O(d^2)\) algorithm, practical for small \(d\).

\paragraph{Geometric Approach}
Each term \(|u_i - w_i + t(v_i - u_i)|\) is linear in \(t\). The problem reduces to finding where the upper envelope of these \(2d\) lines reaches height \(\varepsilon\) over \(t \in [0,1]\). A sweep-line algorithm, inspired by Bentley-Ottmann~\cite{computational_geometry}, maintains the upper envelope using a doubly-linked list and a priority queue for intersections. This runs in \(\O(d \log d)\) time. Pseudocode is provided in \cref{algo:solve_chebyshev_init,algo:solve_chebyshev}, and an example is illustrated in \cref{fig:chebyshev_algo}.

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
		\includegraphics{tikz-fig/chebyshev-algo-1.pdf}
    \caption{All candidate lines}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \includegraphics{tikz-fig/chebyshev-algo-2.pdf}
    \caption{Lines that are not fully negative}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \includegraphics{tikz-fig/chebyshev-algo-3.pdf}
    \caption{Lines that are not fully below another line}
  \end{subfigure}\\
  \begin{subfigure}[t]{0.3\textwidth}
    \includegraphics{tikz-fig/chebyshev-algo-4.pdf}
    \caption{Find next intersection. Here between topmost line so check for solution.}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \includegraphics{tikz-fig/chebyshev-algo-5.pdf}
    \caption{Find next intersection. No solution found}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \includegraphics{tikz-fig/chebyshev-algo-6.pdf}
    \caption{Check final line for an intersection}
  \end{subfigure}
  \caption{Line representation for solving \(\delta_\infty((0,0,0) + t(-2,0,3), (-2,-1,1)) = 1.5\).}
  \label{fig:chebyshev_algo}
\end{figure}

\begin{algorithm}[ht]
  \DontPrintSemicolon
  \KwData{vectors \(u, v, w \in \R^d\), \(\varepsilon > 0\)}
  \BlankLine
  \(candidates \gets \set{(2i, u_i - w_i, v_i - u_i), (2i+1, w_i - u_i, u_i - v_i) | i = 0, \dots, d - 1}\) \;
  \(queue \gets PriorityQueue()\) \;
  \(list \gets Array(|candidates|)\) \;
  sort candidates according to second component descendingly,
  in case of ties use the third component as tie breaker descendingly \;
  \(PREV \gets 0, NEXT \gets 1\) \tcp{constants for readability}
  \(curr \gets -1\) \;
  \For{\((i, a, b) \in candidates\)}{
    \If{\(curr = -1\)} {
      \(curr \gets i, a' \gets a, b' \gets b\)\;
      \(list[curr] \gets (-1, -1, a, b)\) \;
      \Continue
    }

    \If{\( a' + b' \geq a + b\)}{
      \Continue \tcp{new line fully below current line so never maximum}
    }

    \(list[curr][NEXT] \gets i, list[i] \gets (curr, -1, a, b)\) \;
    \(intersection \gets \frac{a' - a}{b - b'}\) \tcp{always in \([0,1]\)}
    \(queue.insert\_with\_priority((curr, i), intersection)\) \;
    \(curr \gets i, a' \gets a, b' \gets b\) \;
  }

  \caption{chebyshev\_solver\_initialization(\(u, v, w\))}
  \label{algo:solve_chebyshev_init}
\end{algorithm}

\begin{algorithm}[ht]
  \DontPrintSemicolon
  \KwData{vectors \(u, v, w \in \R^d\), \(\varepsilon > 0\)}
  \KwResult{Solution to \cref{eq:solve_chebyshev}}
  \BlankLine
  \(chebyshev\_solver\_initialization(u, v, w)\) \;
  \(last\_intersection \gets 0\) \;
  \While{\(\lnot queue.empty()\)}{
    \((i, j), intersection \gets queue.poll()\) \;
    \If{\(list[i][PREV] = -1 \lor list[j][PREV] = -1\)}{
      \Continue \tcp{One of the lines already removed, no intersection}
    }
    \If{\(i = HEAD\)}{
      \(HEAD \gets j\) \;
      \(\_, \_, a, b \gets list[i]\) \;
      \If{\(b = 0\)}{
        \If{\(a = \varepsilon\) }{
          Mark \(last\_intersection\) as earliest solution or \(intersection\) as last solution \;
        }
        \(last\_intersection \gets intersection\) \;
        \Continue
      }
      \(solution \gets \frac{\varepsilon - a}{b}\) \;
      Mark \(solution\) as earliest or last solution if \(solution \in [last\_intersection, intersection]\) \;
      \(last\_intersection \gets intersection\) \;
      \Continue
    }
    \(before_i \gets list[i][PREV]\) \;
    \(list[before_i][NEXT] \gets j, list[j][PREV] \gets before_i\) \;
    \(list[i][PREV] \gets -1\) \tcp{mark as removed}
    \(last\_intersection \gets intersection\) \;
    \If{\(before_i \neq HEAD\)}{
      \(\_, \_, a, b \gets list[j]\) \;
      \(\_, \_, a', b' \gets list[before_i]\) \;
      \(intersection \gets \frac{a' - a}{b - b'}\) \tcp{also in \([0,1]\)}
      \(queue.insert\_with\_priority((before_i, j), intersection)\) \;
    }
  }
  Check for solution in \([last\_intersection, 1]\) \;

  \caption{chebyshev\_solver(\(u, v, w, \varepsilon\))}
  \label{algo:solve_chebyshev}
\end{algorithm}

\paragraph{Algebraic Approach}
A simpler and more efficient \(\O(d)\) method exists. Observe that:
	\[\max_{i} |a_i + t b_i| = \varepsilon \iff \forall i: |a_i + t b_i| \leq \varepsilon \ \land\ \exists i: |a_i + t b_i| = \varepsilon.\]
Each inequality \(|a_i + t b_i| \leq \varepsilon\) defines an interval for \(t\). If \(b_i > 0\), the interval is \([(-\varepsilon - a_i)/b_i, (\varepsilon - a_i)/b_i]\). If \(b_i < 0\), we flip signs to get an equivalent interval. If \(b_i = 0\), the inequality becomes \(|a_i| \leq \varepsilon\); if false, there is no solution.

The solution set is the intersection of these intervals, computable in \(\O(d)\) time by tracking the maximum left boundary and minimum right boundary. We then check if any term equals \(\varepsilon\) within this interval.

\paragraph{Summary}
We presented three methods for the Chebyshev case: a na\"ive \(\O(d^2)\) method, a geometric \(\O(d \log d)\) method, and an algebraic \(\O(d)\) method. The linear-time algebraic method is preferred for its simplicity and efficiency.

As a final note on the practical implementation of these equation-solving algorithms, we emphasize the need to account for floating-point inaccuracies. Special care must be taken to ensure that essential solutions are nost lost. For instance, when computing the solution interval for a line segment relative to one of its endpoints, the result should never be an empty interval due solely to numerical error.
